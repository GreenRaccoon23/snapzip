package main

import (
	"archive/tar"
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"syscall"
	"unsafe"

	"github.com/golang/snappy"
	// syscall "golang.org/x/sys/unix"
)

var (
	buffer          bytes.Buffer
	doSingleArchive bool
	doQuiet         bool
	dstArchive      string
	trgtFiles       []string
)

func init() {
	chkHelp()
	flags()
}

// Check whether user requested help.
func chkHelp() {
	if len(os.Args) < 2 {
		return
	}

	switch os.Args[1] {
	case "-h", "h", "help", "--help", "-H", "H", "HELP", "--HELP", "-help", "--h", "--H":
		help(0)
	}

}

// Print help and exit with a status code.
func help(status int) {
	defer os.Exit(status)
	fmt.Printf(
		"%s\n\n  %s\n\n  %s\n%s\n\n  %s\n%s\n%s\n%s\n%s\n%s\n%s\n\n  %s\n%s\n%s\n%s\n",
		"sz",
		"Usage: sz [option ...] [file ...]",
		"Description:",
		"    Compress/uncompress files to/from snappy archives.",
		"Notes:",
		"    Compressed files are named as '<file>.sz'",
		"    This program automatically determines",
		"      whether files should be compressed or decompressed",
		"      by checking their filetypes (and reading file signatures).",
		"    This program can also compress directories;",
		"      they are automatically placed into a tar archive beforehand.",
		"Options:",
		"   -a <name>    Compress all files into a single snappy archive.",
		"                (default is to compress each file individually)",
		"   -q           Do not show any output",
	)
}

// Parse user arguments and modify global variables accordingly.
func flags() {
	// Program requires at least one user argument.
	// Print help and exit with status 1 if none have been received.
	if len(os.Args) < 2 {
		help(1)
	}

	// Parse commandline arguments.
	flag.StringVar(&dstArchive, "a", "", "")
	flag.BoolVar(&doQuiet, "q", false, "")
	flag.Parse()

	// Modify global variables based on commandline arguments.
	trgtFiles = os.Args[1:]
	if !doQuiet && dstArchive == "" {
		return
	}

	if doQuiet {
		bools := []string{"-s", "-q"}
		trgtFiles = filter(trgtFiles, bools...)
	}
	if dstArchive != "" {
		doSingleArchive = true
		trgtFiles = filter(trgtFiles, dstArchive)
	}
	return
}

// Remove elements in a slice (if they exist).
// Only remove EXACT matches.
func filter(slc []string, args ...string) (filtered []string) {
	for _, s := range slc {
		if slcHas(slc, s) {
			continue
		}
		filtered = append(filtered, s)
	}
	return
}

// Check whether a slice contains a string.
// Only return true if an element in the slice EXACTLY matches the string.
// If testing for more than one string,
//   return true if ANY of them match an element in the slice.
func slcHas(slc []string, args ...string) bool {
	for _, s := range slc {
		for _, a := range args {
			if s == a {
				return true
			}
		}
	}
	return false
}

func main() {
	defer os.Exit(0)
	//if doSingleArchive
	for _, f := range trgtFiles {
		err := analyze(f)
		if err != nil && !doQuiet {
			fmt.Println(err)
		}
	}
	/*
		name := "amdapp-sdk"
		err := analyze(name)
		if err != nil {
			print(err)
		}
	*/
}

// Pass to fmt.Println().
func print(a ...interface{}) {
	if doQuiet {
		return
	}
	switch len(a) {
	case 0:
		fmt.Println()
	default:
		fmt.Println(a...)
	}
}

// Pass to fmt.Printf().
func printf(format string, a ...interface{}) {
	if doQuiet {
		return
	}
	fmt.Printf(format, a...)
}

// Concatenate strings.
func concat(slc ...string) (concatenated string) {
	for _, s := range slc {
		buffer.WriteString(s)
	}
	concatenated = buffer.String()
	buffer.Reset()
	return
}

func analyze(filename string) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	switch filetype(file) {

	// If the file is a directory, tar it and then compress the new tarball.
	case "dir":
		// Tar it.
		tarFile, err := tarDir(file)
		if err != nil {
			return err
		}
		defer tarFile.Close()
		// Compress it.
		compressed, err := snap(tarFile)
		defer compressed.Close()
		if err != nil {
			return err
		}

	// If the file is a snappy file, uncompress it.
	case "sz":
		// Uncompress it.
		err := unsnap(file)
		if err != nil {
			return err
		}

	// If the file is any other type, compress it.
	default:
		// Compress it.
		compressed, err := snap(file)
		defer compressed.Close()
		if err != nil {
			return err
		}
	}

	return nil
}

// Determine the filetype of a file.
func filetype(file *os.File) string {
	switch {
	case isDir(file):
		return "dir"
	case isSz(file):
		return "sz"
	case isTar(file):
		return "tar"
	default:
		return "other"
	}
}

// Check whether a file is a directory.
func isDir(file *os.File) bool {
	fi, err := file.Stat()
	if err != nil {
		return false
	}
	return fi.IsDir()
}

// Check a file's contents for a snappy file signature.
func isSz(file *os.File) bool {
	total := 10
	bytes := make([]byte, total)
	n, _ := file.ReadAt(bytes, 0)
	if n < total {
		return false
	}

	szSig := []byte{255, 6, 0, 0, 115, 78, 97, 80, 112, 89}
	for i, b := range bytes {
		if b != szSig[i] {
			return false
		}
	}
	return true
}

// Check a file's contents for a tar file signature.
func isTar(file *os.File) bool {
	bytes := make([]byte, 5)
	n, _ := file.ReadAt(bytes, 257)
	if n < 5 {
		return false
	}

	tarSig := []byte{117, 115, 116, 97, 114}
	for i, b := range bytes {
		if b != tarSig[i] {
			return false
		}
	}
	return true
}

// Credits to jimt from here:
// https://stackoverflow.com/questions/22421375/how-to-print-the-bytes-while-the-file-is-being-downloaded-golang
//
// PassThru wraps an existing io.Reader or io.Writer.
// It simply forwards the Read() or Write() call, while displaying
// the results from individual calls to it.
type PassThru struct {
	io.Reader
	io.Writer
	total    uint64 // Total # of bytes transferred
	length   uint64 // Expected length
	progress float64
}

// Write 'overrides' the underlying io.Reader's Read method.
// This is the one that will be called by io.Copy(). We simply
// use it to keep track of byte counts and then forward the call.
// NOTE: Print a new line after any commands which use this io.Reader.
func (p *PassThru) Read(b []byte) (int, error) {
	n, err := p.Reader.Read(b)
	if n <= 0 {
		return n, err
	}

	p.total += uint64(n)
	percentage := float64(p.total) / float64(p.length) * float64(100)
	percent := int(percentage)
	if percentage-p.progress < 1 && percent != 100 {
		return n, err
	}

	total := fmtSize(p.total)
	goal := fmtSize(p.length)

	fmt.Printf("\r%s", strings.Repeat(" ", 70))
	fmt.Printf("\r  %v%%   %v / %v", percent, total, goal)

	p.progress = percentage

	return n, err
}

// Write 'overrides' the underlying io.Writer's Write method.
// This is the one that will be called by io.Copy(). We simply
// use it to keep track of byte counts and then forward the call.
// NOTE: Print a new line after any commands which use this io.Writer.
func (p *PassThru) Write(b []byte) (int, error) {
	n, err := p.Writer.Write(b)
	if n <= 0 || doQuiet {
		return n, err
	}

	p.total += uint64(n)
	percentage := float64(p.total) / float64(p.length) * float64(100)
	percent := int(percentage)
	if percentage-p.progress < 1 && percent != 100 {
		return n, err
	}

	total := fmtSize(p.total)
	goal := fmtSize(p.length)
	ratio := fmt.Sprintf("%.3f", float64(p.total)/float64(p.length))

	fmt.Printf("\r%s", strings.Repeat(" ", 70))
	fmt.Printf("\r  %v%%   %v / %v = %v", percent, total, goal, ratio)

	p.progress = percentage

	return n, err
}

// Slight variation of bytefmt.ByteSize() from:
// https://github.com/pivotal-golang/bytefmt/blob/master/bytes.go
const (
	BYTE     = 1.0
	KIBIBYTE = 1000 * BYTE
	MEBIBYTE = 1000 * KIBIBYTE
	GIBIBYTE = 1000 * MEBIBYTE
	TEBIBYTE = 1000 * GIBIBYTE
)

func fmtSize(bytes uint64) string {
	unit := ""
	value := float64(bytes)

	switch {
	case bytes >= TEBIBYTE:
		unit = "TiB"
		value = value / TEBIBYTE
	case bytes >= GIBIBYTE:
		unit = "GiB"
		value = value / GIBIBYTE
	case bytes >= MEBIBYTE:
		unit = "MiB"
		value = value / MEBIBYTE
	case bytes >= KIBIBYTE:
		unit = "KiB"
		value = value / KIBIBYTE
	case bytes >= BYTE:
		unit = "Bytes"
	case bytes == 0:
		return "0"
	}

	stringValue := fmt.Sprintf("%.1f", value)
	//return fmt.Sprintf("%s %s", stringValue, unit)
	return concat(stringValue, " ", unit)
}

// Create a file if it doesn't exist. Otherwise, just open it.
func create(filename string, mode int) (*os.File, error) {
	file, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.FileMode(mode))
	return file, err
}

// Compress a file to a snappy archive.
func snap(src *os.File) (dst *os.File, err error) {
	// Create the destination file.
	dstName := concat(src.Name(), ".sz")
	dst, err = create(dstName, 0777)
	if err != nil {
		return
	}

	// Read the contents of the source file.
	var srcContents []byte
	srcContents, err = ioutil.ReadAll(src)
	if err != nil {
		return
	}
	srcLength := uint64(len(srcContents))

	// Prepare to turn the destination file into a snappy file.
	dstWriter := &PassThru{Writer: dst, length: srcLength}
	szWriter := snappy.NewWriter(dstWriter)

	// Write the source file's contents to the new snappy file.
	print(dstName)
	_, err = szWriter.Write(srcContents)
	print()
	if err != nil {
		return
	}

	// Re-open the modified file.
	dst, err = os.Open(dstName)
	return
}

// Decompress a snappy archive.
func unsnap(src *os.File) (err error) {
	srcInfo, err := src.Stat()
	if err != nil {
		return
	}
	srcLength := uint64(srcInfo.Size())
	srcName := srcInfo.Name()

	srcReader := &PassThru{Reader: src, length: srcLength}
	szReader := snappy.NewReader(srcReader)

	dstName := strings.TrimSuffix(srcName, ".sz")
	if dstName == srcName {
		dstName = concat(srcName, "-uncompressed")
	}
	dst, err := create(dstName, 0777)
	if err != nil {
		return
	}

	print(srcName)
	_, err = io.Copy(dst, szReader)
	print()

	dst, err = os.Open(dstName)
	if err != nil {
		return
	}
	if isTar(dst) {
		err = untar(dst)
		return
	}
	return
}

// Create a tar archive of a file.
func tarFile(src *os.File) (dst *os.File, err error) {
	if isDir(src) {
		dst, err = tarDir(src)
		return
	}

	// Create the destination file.
	dstName := concat(src.Name(), ".tar")
	dst, err = create(dstName, 0777)
	if err != nil {
		return
	}

	// Read the contents of the source file.
	var srcContents []byte
	srcContents, err = ioutil.ReadAll(src)
	if err != nil {
		return
	}
	srcLength := uint64(len(srcContents))

	// Prepare to turn the destination file into a tar archive.
	dstWriter := &PassThru{Writer: dst, length: srcLength}
	tarWriter := tar.NewWriter(dstWriter)

	// Write the source file's contents to the new tar archive.
	print(dstName)
	_, err = tarWriter.Write(srcContents)
	print()
	if err != nil {
		return
	}

	// Re-open the modified file.
	dst, err = os.Open(dstName)
	return
}

// Append a "/" to a string if it doesn't have one already.
func fmtDir(name *string) {
	s := string(filepath.Separator)
	if !strings.HasSuffix(*name, s) {
		*name = concat(*name, s)
	}
}

// Return the total size in bytes and number of files under a directory.
func dirSize(dir string) (b int64, i int) {
	filepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {
		b += fi.Size()
		i += 1
		return nil
	})
	return
}

// https://github.com/docker/docker/blob/master/pkg/archive/archive.go
type tarAppender struct {
	tarWriter   *tar.Writer
	bufioWriter *bufio.Writer
	// Map inodes to hardlinks.
	hardLinks map[uint64]string
}

// Create a tar archive of a file.
func tarDir(dir *os.File) (dst *os.File, err error) {
	dirName := dir.Name()
	// Create the destination file.
	dstName := concat(dirName, ".tar")
	dst, err = create(dstName, 0777)
	if err != nil {
		return
	}

	var dstWriter io.WriteCloser = dst
	ta := &tarAppender{
		tarWriter:   tar.NewWriter(dstWriter),
		bufioWriter: bufio.NewWriter(nil),
		hardLinks:   make(map[uint64]string),
	}

	defer func() {
		err = ta.tarWriter.Close()
	}()

	var total int
	if !doQuiet {
		_, total = dirSize(dirName)
	}
	root := dirName

	// Walk through the directory.
	// Add a header to the tar archive for each file encountered.
	print(dirName)
	var progress int
	err = filepath.Walk(root, func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		err = ta.add(path, path)
		if err != nil {
			return err
		}

		if doQuiet {
			return nil
		}
		progress += 1
		percent := int(float64(progress) / float64(total) * float64(100))
		fmt.Printf("\r%s", strings.Repeat(" ", 50))
		fmt.Printf("\r  %d / %d files   %d%%", progress, total, percent)
		return nil
	})
	print()

	// Re-open the modified file.
	dst, err = os.Open(dstName)
	if err != nil {
		return
	}
	return
}

// https://github.com/docker/docker/blob/master/pkg/archive/archive.go
func (ta *tarAppender) add(path, name string) error {
	fi, err := os.Lstat(path)
	if err != nil {
		return err
	}

	// If the file is a symlink, find its target.
	var link string
	if fi.Mode()&os.ModeSymlink != 0 {
		if link, err = os.Readlink(path); err != nil {
			return err
		}
	}

	// Create the tar header.
	hdr, err := tar.FileInfoHeader(fi, link)
	if err != nil {
		return err
	}

	// Set the header name.
	// If the file is a directory, add a trailing "/".
	if fi.Mode()&os.ModeDir != 0 {
		fmtDir(&name)
	}
	hdr.Name = name

	// Check if the file has hard links.
	nlink, inode, err := tarSetHeader(hdr, fi.Sys())
	if err != nil {
		return err
	}

	// If any other regular files link to the same inode as this file,
	//   prepare to treat it as a "hardlink" in the header.
	// If the tar archive contains another hardlink to this file's inode,
	//   set it as a "hardlink" in the tar header.
	// Otherwise, treat it as a regular file.
	if fi.Mode().IsRegular() && nlink > 1 {
		// If this file is NOT the first found hardlink to this inode,
		//   set the previously found hardlink as its 'Linkname'.
		if oldpath, ok := ta.hardLinks[inode]; ok {
			hdr.Typeflag = tar.TypeLink
			hdr.Linkname = oldpath
			// Set size to 0 when not adding additional inodes.
			//   Otherwise, the writer's math will not add up correctly.
			hdr.Size = 0

			// If this file IS the first hardlink to this inode,
			//   note the file with its inode and treat it as a regular file.
			// It will become the 'Linkname' for another hardlink
			//   further down in the archive.
		} else {
			ta.hardLinks[inode] = name
		}
	}

	// Find any extended atributes (xattr) of the inode
	//   and set the header accordingly.
	capability, _ := lgetxattr(path, "security.capability")
	if capability != nil {
		hdr.Xattrs = make(map[string]string)
		hdr.Xattrs["security.capability"] = string(capability)
	}

	// Write the header.
	tw := ta.tarWriter
	if err = tw.WriteHeader(hdr); err != nil {
		return err
	}

	// If the file is a regular one,
	//   i.e., not a symlink, directory, or hardlink,
	//   write the file's contents to the buffer.
	if hdr.Typeflag == tar.TypeReg {
		tb := ta.bufioWriter
		file, err := os.Open(path)
		if err != nil {
			return err
		}

		tb.Reset(tw)
		defer tb.Reset(nil)
		_, err = io.Copy(tb, file)
		file.Close()
		if err != nil {
			return err
		}
		err = tb.Flush()
		if err != nil {
			return err
		}
	}
	return nil
}

// https://github.com/docker/docker/blob/master/pkg/archive/archive_unix.go
func tarSetHeader(hdr *tar.Header, stat interface{}) (nlink uint32, inode uint64, err error) {
	s, ok := stat.(*syscall.Stat_t)

	if !ok {
		err = fmt.Errorf("func tarHeader: cannot convert stat value to syscall.Stat_t")
		return
	}

	nlink = uint32(s.Nlink)
	inode = uint64(s.Ino)

	// Currently go does not fil in the major/minors
	if s.Mode&syscall.S_IFBLK != 0 ||
		s.Mode&syscall.S_IFCHR != 0 {
		hdr.Devmajor = int64(major(uint64(s.Rdev)))
		hdr.Devminor = int64(minor(uint64(s.Rdev)))
	}

	return
}

// Return a nil slice and nil error if the xattr is not set.
func lgetxattr(path string, attr string) ([]byte, error) {
	pathBytes, err := syscall.BytePtrFromString(path)
	if err != nil {
		return nil, err
	}
	attrBytes, err := syscall.BytePtrFromString(attr)
	if err != nil {
		return nil, err
	}

	dest := make([]byte, 128)
	destBytes := unsafe.Pointer(&dest[0])
	sz, _, errno := syscall.Syscall6(syscall.SYS_LGETXATTR, uintptr(unsafe.Pointer(pathBytes)), uintptr(unsafe.Pointer(attrBytes)), uintptr(destBytes), uintptr(len(dest)), 0, 0)
	if errno == syscall.ENODATA {
		return nil, nil
	}
	if errno == syscall.ERANGE {
		dest = make([]byte, sz)
		destBytes := unsafe.Pointer(&dest[0])
		sz, _, errno = syscall.Syscall6(syscall.SYS_LGETXATTR, uintptr(unsafe.Pointer(pathBytes)), uintptr(unsafe.Pointer(attrBytes)), uintptr(destBytes), uintptr(len(dest)), 0, 0)
	}
	if errno != 0 {
		return nil, errno
	}

	return dest[:sz], nil
}

func major(device uint64) uint64 {
	return (device >> 8) & 0xfff
}

func minor(device uint64) uint64 {
	return (device & 0xff) | ((device >> 12) & 0xfff00)
}

/*
// Extract a tar archive.
func untar(src *os.File) (err error) {
	srcInfo, err := src.Stat()
	if err != nil {
		return
	}
	srcLength := uint64(srcInfo.Size())
	srcName := srcInfo.Name()

	sr := &PassThru{Reader: src, length: srcLength}
	tr := tar.NewReader(sr)

	dstName := strings.TrimSuffix(srcName, ".tar")
	if dstName == srcName {
		dstName = concat(srcName, "-uncompressed")
	}
	fmt.Println(dstName)
	_, err = io.Copy(dst, tr)
	fmt.Println()
	return
}
*/

// Extract a tar archive.
func untar(file *os.File) (err error) {
	fi, err := file.Stat()
	if err != nil {
		return
	}
	name := fi.Name()
	total := int64(fi.Size())

	tr := tar.NewReader(file)

	print(name)
	var progress int64
	for {
		var hdr *tar.Header
		hdr, err = tr.Next()
		if err == io.EOF {
			// Break if the end of the tar archive has been reached.
			err = nil
			break
		}
		if err != nil {
			break
		}

		switch hdr.Typeflag {

		// Extract a directory.
		case tar.TypeDir:
			err = os.MkdirAll(hdr.Name, os.FileMode(hdr.Mode))
			if err != nil {
				break
			}

		// Extract a file.
		case tar.TypeReg, tar.TypeRegA:
			var w *os.File
			w, err = os.OpenFile(hdr.Name, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.FileMode(hdr.Mode))
			if err != nil {
				break
			}
			_, err = io.Copy(w, tr)
			if err != nil {
				break
			}
			w.Close()

		// Extract a hard link.
		case tar.TypeLink:
			err = os.Link(hdr.Linkname, hdr.Name)
			if err != nil {
				break
			}

		// Extract a symlink.
		case tar.TypeSymlink:
			err = os.Symlink(hdr.Linkname, hdr.Name)
			if err != nil {
				break
			}

		// Continue loop without printing progress.
		default:
			// Print anything missed for debugging purposes.
			printf(
				"Did not extract header %v with typeflag %v\n",
				hdr.Name, hdr.Typeflag,
			)
			continue
		}

		// Print progress.
		if doQuiet || hdr.Size == int64(0) {
			continue
		}
		progress = progress + hdr.Size
		percent := progress / total * 100
		fmt.Printf("\r%s", strings.Repeat(" ", 70))
		fmt.Printf("\r  %v%%   %v / %v", percent, progress, total)
	}
	print()

	if err != nil {
		err = fmt.Errorf("%v\nFailed to extract %v", err)
	}
	return
}

/*
// Create a tar archive of a file.
func tarchiveDir(dir *os.File) (dst *os.File, err error) {
	dirName := dir.Name()
	// Create the destination file.
	dstName := concat(dirName, ".tar")
	dst, err = create(dstName, 0777)
	if err != nil {
		return
	}

	/*
		// Read the contents of the source file.
		var srcContents []byte
		srcContents, err = ioutil.ReadAll(dir)
		if err != nil {
			return
		}
		srcLength := uint64(len(srcContents))

		// Prepare to turn the destination file into a tar archive.
		dstWriter := &PassThru{Writer: dst, length: srcLength}
		tw := tar.NewWriter(dstWriter)
		defer tw.Close()

		// Write the source file's contents to the new tar archive.
		print(dstName)
		_, err = tw.Write(srcContents)
		print()
		if err != nil {
			return
		}
*/
/*
	var dstWriter io.WriteCloser = dst
	tw := tar.NewWriter(dstWriter)
	defer tw.Close()

	print(dstName)

	err = tarWrite(dirName, tw)
	if err != nil {
		return
	}
	//print()

	// Re-open the modified file.
	dst, err = os.Open(dstName)
	return
}
/*

/*
// Slight variation of bytefmt.ByteSize() from:
// https://github.com/pivotal-golang/bytefmt/blob/master/bytes.go
const (
	BYTE     = 1.0
	KILOBYTE = 1024 * BYTE
	MEGABYTE = 1024 * KILOBYTE
	GIGABYTE = 1024 * MEGABYTE
	TERABYTE = 1024 * GIGABYTE
)

func fmtSize(bytes uint64) string {
	unit := ""
	value := float64(bytes)

	switch {
	case bytes >= TERABYTE:
		unit = "TB"
		value = value / TERABYTE
	case bytes >= GIGABYTE:
		unit = "GB"
		value = value / GIGABYTE
	case bytes >= MEGABYTE:
		unit = "MB"
		value = value / MEGABYTE
	case bytes >= KILOBYTE:
		unit = "KB"
		value = value / KILOBYTE
	case bytes >= BYTE:
		unit = "Bytes"
	case bytes == 0:
		return "0"
	}

	stringValue := fmt.Sprintf("%.1f", value)
	//return fmt.Sprintf("%s %s", stringValue, unit)
	return concat(stringValue, " ", unit)
}
*/

/*
func analyze(filename string) {
	fi, err := os.Stat(dir); err != nil {
	file, err := os.Open(filename)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()

	dir, err := isDir(file)
	if err != nil {
		fmt.Println(err)
		return
	}
	if dir {
		TEST(filename, "is dir")
		tar(file)
		filename = concat(filename, ".tar")
	}
	TEST(filename, "is not dir")
	return
}

// Return true if a file is a directory.
//   Also return any errors encountered.
func isDir(file *os.File) (bool, error) {
	fi, err := file.Stat()
	if err != nil {
		return false, err
	}
	if mode := fi.Mode(); mode.IsDir() {
		return true, nil
	}
	return false, nil
}
*/

/*
func (p *PassThruWriter) Write(b []byte) (int, error) {
	n, err := p.Writer.Write(b)
	if n > 0 {
		p.total += int64(n)
		percent := float64(p.total) / float64(p.length) * float64(100)
		//i := int(percentage / float64(10))
		i := int(percent)
		if percent-p.progress > 2 {
			fmt.Printf("\r-> %v/%v bytes          %v%%", p.total, p.length, i)
			p.progress = percent
		}
	}
	return n, err
}
*/

/*
func genLogFile() {
	pattern := ConcatBy(Patterns, ",")
	fileName := Concat("lss-results_", pattern)

	RemoveIfExists(fileName)
	LogFile = Create(fileName)

	header := fmt.Sprintf(
		"Search results for:\n    \"%v\"\nunder:\n    \"%v\"\n",
		pattern,
		Root,
	)
	Write(header, LogFile)
}
*/
